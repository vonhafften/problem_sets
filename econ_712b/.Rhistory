}
if (j == 2){
target <- decision_high[i]
}
dist[target, 1] <- dist[target, 1] + dist0[i, j] * Q[j, 1]
dist[target, 2] <- dist[target, 2] + dist0[i, j] * Q[j, 2]
}
}
}
diff <- sum(abs(dist - dist0))
if (abs(sum(dist) - 1) > .00001 | abs(sum(dist0) - 1) >  .00001 ) {
print("PDFs aren't PDF!")
plot(dist[,1], type ="l")
lines(dist[,2], col = "red")
print(sum(dist))
print(sum(dist0))
break
}
dist0 <- dist
iter <- iter + 1
}
k_supply <- sum(apply(dist, 1, sum)*k)
print(paste("Capital Supply:", k_supply))
diff <- k_demand - k_supply
iter_master <- iter_master + 1
k_demand <- k[which.min(abs(0.9*k_demand + 0.1*k_supply - k))]
}
# This chunk runs the simulation.  No need to run it every time you knit.
# parameters
beta <- 0.95
gamma <- 3
alpha <- 0.36
delta <- 0.08
l_low <- 0.7
l_high <- 1.1
Q <- matrix(c(0.85, 0.05, 0.15, 0.95), nrow = 2)
# capital grid
min_k <- -2
max_k <- 20
inc_k <- 0.01
k <- seq(min_k, max_k, by = inc_k)
n <- length(k)
ones <- rep(1, times=n)
# initialize value grid
v_low <- log(k-min_k+inc_k)
v_high <- log(k-min_k+inc_k)
# initialize decision rule grid
decision_low <- rep(0, times=n)
decision_high <- rep(0, times=n)
# initial guess
k_demand <- 6
diff <- 10000
k_tol <- 0.02
dist_tol <- .01
iter_master <- 1
max_iter <- 1000
# Master loop. Takes a capital demand level. Calculates interest rates and wages. Solve the household problem.  Find marginal distribution of capital supply. Check if they are close. Then reruns with capital demand that is halfway between the previous guess and the implied capital supply.
while (abs(diff) > k_tol & iter_master < max_iter) {
print(iter_master)
print(paste("Capital Demand:", k_demand))
# find interest rate from k_demand guess
r_low <- alpha * k_demand ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_demand ^ (alpha - 1) * l_high ^ (1 - alpha)
# wages from zero profit condition
w_low <- (k_demand ^ (alpha) * l_low ^ (1-alpha) - r_low * k_demand)/l_low
w_high <- (k_demand ^ (alpha) * l_high ^ (1-alpha) - r_high * k_demand)/l_high
# create consumption matrices
# (columns are different values of a; rows are values of a')
c_matrix_low <- w_low * l_low + r_low * ones %*% t(k)  + (1-delta) * ones %*% t(k) - k %*% t(ones)
c_matrix_high <- w_high * l_high + r_high * ones %*% t(k) + (1-delta) * ones %*% t(k)  - k %*% t(ones)
# create flow utility matrices and set negative consumption levels to low value
utility_matrix_low <- (c_matrix_low^(1-gamma))/(1-gamma)
utility_matrix_low[c_matrix_low < 0|!is.finite(utility_matrix_low)] <- -1000
utility_matrix_high <- (c_matrix_high^(1-gamma))/(1-gamma)
utility_matrix_high[c_matrix_high < 0|!is.finite(utility_matrix_high)] <- -1000
test <- 10
iter_hh <- 1
# solve household bellman equations:
while (test != 0 & iter_hh < max_iter) {
# create value matrix for different a and a' values with transition probabilities
# to next period shock
value_matrix_low <- utility_matrix_low + beta * Q[1, 1] * v_low %*% t(ones) +
beta * Q[1, 2] * v_high %*% t(ones)
value_matrix_high <- utility_matrix_high + beta * Q[2, 1] * v_low %*% t(ones) +
beta * Q[2, 2] * v_high %*% t(ones)
# find max utility
tv_low <- apply(value_matrix_low, 2, max)
tv_high <- apply(value_matrix_high, 2, max)
# find column with max utility
tdecision_low <- apply(value_matrix_low, 2, which.max)
tdecision_high <- apply(value_matrix_high, 2, which.max)
# update test variable so loop ends if no changes from previous iteration
test <- max(tdecision_low - decision_low) + max(tdecision_high - decision_high)
# update value grid
v_low <- tv_low
v_high <- tv_high
# update decision rule
decision_low <- tdecision_low
decision_high <- tdecision_high
iter_hh <- iter_hh + 1
}
# Finds marginal distribution of capital supply
diff <- 1000
dist0 <- matrix(rep(1/(2*n), times = 2*n), ncol = 2)
dist <- dist0
iter <- 1
while (diff > dist_tol & iter < max_iter ) {
dist <- 0*dist0
for (i in 1:n) {
for (j in 1:2) {
if (dist0[i, j] > .Machine$double.xmin) {
if (j == 1){
target <- decision_low[i]
}
if (j == 2){
target <- decision_high[i]
}
dist[target, 1] <- dist[target, 1] + dist0[i, j] * Q[j, 1]
dist[target, 2] <- dist[target, 2] + dist0[i, j] * Q[j, 2]
}
}
}
diff <- sum(abs(dist - dist0))
if (abs(sum(dist) - 1) > .00001 | abs(sum(dist0) - 1) >  .00001 ) {
print("PDFs aren't PDF!")
plot(dist[,1], type ="l")
lines(dist[,2], col = "red")
print(sum(dist))
print(sum(dist0))
break
}
dist0 <- dist
iter <- iter + 1
}
k_supply <- sum(apply(dist, 1, sum)*k)
print(paste("Capital Supply:", k_supply))
diff <- k_demand - k_supply
iter_master <- iter_master + 1
k_demand <- k[which.min(abs(0.9*k_demand + 0.1*k_supply - k))]
}
# save policy function based on decision rule
policy_function_low <- tibble(k = k, k_prime = min_k + decision_low*inc_k) %>%
mutate(c = w_low * l_low + r_low * k + (1-delta) * k - k_prime)
policy_function_high <- tibble(k = k, k_prime = min_k + decision_high*inc_k) %>%
mutate(c = w_high * l_high + r_high * k + (1-delta) * k - k_prime)
save(list = ls(), file = "ps4_vonhafften_1c.RData")
load("ps4_vonhafften_1a.RData")
k_bar <- (k_demand + k_supply)/2
r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high
stationary_dist <- apply(dist, 2, sum)
tibble(capital = k_bar,
wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>%
pivot_longer(cols = everything(),
names_to ="variable",
values_to = "equilibrium values") %>%
kable(digits = 3)
load("ps4_vonhafften_1c.RData")
k_bar <- (k_demand + k_supply)/2
r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high
stationary_dist <- apply(dist, 2, sum)
tibble(capital = k_bar,
wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>%
pivot_longer(cols = everything(),
names_to ="variable",
values_to = "equilibrium values") %>%
kable(digits = 3)
load("ps4_vonhafften_1a.RData")
k_bar <- (k_demand + k_supply)/2
r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high
stationary_dist <- apply(dist, 2, sum)
nodebt <- tibble(capital = k_bar,
wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>%
pivot_longer(cols = everything(),
names_to ="variable",
values_to = "baseline")
load("ps4_vonhafften_1c.RData")
k_bar <- (k_demand + k_supply)/2
r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high
stationary_dist <- apply(dist, 2, sum)
tibble(capital = k_bar,
wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>%
pivot_longer(cols = everything(),
names_to ="variable",
values_to = "with debt") %>%
full_join(nodebt)
kable(digits = 3)
load("ps4_vonhafften_1a.RData")
k_bar <- (k_demand + k_supply)/2
r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high
stationary_dist <- apply(dist, 2, sum)
nodebt <- tibble(capital = k_bar,
wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>%
pivot_longer(cols = everything(),
names_to ="variable",
values_to = "baseline")
load("ps4_vonhafften_1c.RData")
k_bar <- (k_demand + k_supply)/2
r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high
stationary_dist <- apply(dist, 2, sum)
tibble(capital = k_bar,
wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>%
pivot_longer(cols = everything(),
names_to ="variable",
values_to = "with debt") %>%
full_join(nodebt, ., by ="variable") %>%
kable(digits = 3)
# Solves bellman equation based on parameters above.
solve_bellman_d <- function() {
ones <- rep(1, times=n)
# initialize value grid and decision rule grid
v <- rep(0, times=n)
decision <- rep(0, times=n)
# create consumption and utility matrixes
# (columns are different values of k; rows are values of k')
c_matrix <- z_d*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
utility_matrix <- (c_matrix^(1-gamma))/(1-gamma)
utility_matrix[c_matrix < 0|!is.finite(utility_matrix)] <- -1000
test <- 10
while (test != 0) {
# create value matrix for all different k and k' values
value_matrix <- utility_matrix + beta * v %*% t(ones)
# find column max with max utility
tv <- apply(value_matrix, 2, max)
tdecision <- apply(value_matrix, 2, which.max)
# loop ends if no changes from previous iteration
test <- max(tdecision - decision)
# update value grid and decision rule
decision <- tdecision
v <- tv
}
# capital and consumption decision rule
policy_function_d <<- tibble(k = k, k_prime = min_k + decision*inc_k) %>%
mutate(c = z_d*k_prime^cd_k + (1-delta)*k - k_prime)
v_d <<- v
}
# Solves bellman equation based on parameters above.
solve_bellman_s <- function() {
ones <- rep(1, times=n)
# initialize value grid and decision rule grid
v_l <- rep(0, times=n)
v_h <- rep(0, times=n)
decision_l <- rep(0, times=n)
decision_h <- rep(0, times=n)
# create consumption and utility matrixes
# (columns are different values of k; rows are values of k')
c_l_matrix <- z_l*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
c_h_matrix <- z_h*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
utility_l_matrix <- (c_l_matrix^(1-gamma))/(1-gamma)
utility_h_matrix <- (c_h_matrix^(1-gamma))/(1-gamma)
utility_l_matrix[c_l_matrix < 0|!is.finite(utility_l_matrix)] <- -1000
utility_h_matrix[c_h_matrix < 0|!is.finite(utility_h_matrix)] <- -1000
test <- 10
while (test != 0) {
# create value matrix for all different k and k' values
value_l_matrix <- utility_l_matrix + beta * (p_ll * v_l %*% t(ones) + p_lh * v_h %*% t(ones))
value_h_matrix <- utility_h_matrix + beta * (p_hl * v_l %*% t(ones) + p_hh * v_h %*% t(ones))
# find column max with max utility
tv_l <- apply(value_l_matrix, 2, max)
tv_h <- apply(value_h_matrix, 2, max)
tdecision_l <- apply(value_l_matrix, 2, which.max)
tdecision_h <- apply(value_h_matrix, 2, which.max)
# loop ends if no changes from previous iteration
test <- abs(max(tdecision_l - decision_l))+abs(max(tdecision_h - decision_h))
# update value grid and decision rule
decision_l <- tdecision_l
decision_h <- tdecision_h
v_l <- tv_l
v_h <- tv_h
}
# capital and consumption decision rule
policy_function_l <<- tibble(k = k, k_prime = min_k + decision_l*inc_k) %>%
mutate(c = z_l*k_prime^cd_k + (1-delta)*k - k_prime)
policy_function_h <<- tibble(k = k, k_prime = min_k + decision_h*inc_k) %>%
mutate(c = z_h*k_prime^cd_k + (1-delta)*k - k_prime)
v_l <<- v_l
v_h <<- v_h
}
solve_bellman_d()
# parameters
beta <- 0.95
delta <- 0.1
z_d <- 1
gamma <- 2
cd_k <- 0.35 # cobb-douglas coefficient on capital
cd_l <- 0.65 # cobb-douglas coefficient on labor
# additional parameters for stochastic model
z_l <- .8
z_h <- 1.2
p_ll <- .9
p_hl <- .1
p_lh <- .1
p_hh <- .9
# capital grid
min_k <- 0.005
max_k <- 10
inc_k <- 0.005
k <- seq(min_k, max_k, by = inc_k)
n <- length(k)
solve_ss_d <- function() {
# Steady state values
k_bar <<- ((beta^(-1)-(1-delta))/(cd_k * z_d))^(1/(cd_k-1))
c_bar <<- z_d * k_bar^cd_k - delta * k_bar
}
# Solves bellman equation based on parameters above.
solve_bellman_d <- function() {
ones <- rep(1, times=n)
# initialize value grid and decision rule grid
v <- rep(0, times=n)
decision <- rep(0, times=n)
# create consumption and utility matrixes
# (columns are different values of k; rows are values of k')
c_matrix <- z_d*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
utility_matrix <- (c_matrix^(1-gamma))/(1-gamma)
utility_matrix[c_matrix < 0|!is.finite(utility_matrix)] <- -1000
test <- 10
while (test != 0) {
# create value matrix for all different k and k' values
value_matrix <- utility_matrix + beta * v %*% t(ones)
# find column max with max utility
tv <- apply(value_matrix, 2, max)
tdecision <- apply(value_matrix, 2, which.max)
# loop ends if no changes from previous iteration
test <- max(tdecision - decision)
# update value grid and decision rule
decision <- tdecision
v <- tv
}
# capital and consumption decision rule
policy_function_d <<- tibble(k = k, k_prime = min_k + decision*inc_k) %>%
mutate(c = z_d*k_prime^cd_k + (1-delta)*k - k_prime)
v_d <<- v
}
# Solves bellman equation based on parameters above.
solve_bellman_s <- function() {
ones <- rep(1, times=n)
# initialize value grid and decision rule grid
v_l <- rep(0, times=n)
v_h <- rep(0, times=n)
decision_l <- rep(0, times=n)
decision_h <- rep(0, times=n)
# create consumption and utility matrixes
# (columns are different values of k; rows are values of k')
c_l_matrix <- z_l*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
c_h_matrix <- z_h*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
utility_l_matrix <- (c_l_matrix^(1-gamma))/(1-gamma)
utility_h_matrix <- (c_h_matrix^(1-gamma))/(1-gamma)
utility_l_matrix[c_l_matrix < 0|!is.finite(utility_l_matrix)] <- -1000
utility_h_matrix[c_h_matrix < 0|!is.finite(utility_h_matrix)] <- -1000
test <- 10
while (test != 0) {
# create value matrix for all different k and k' values
value_l_matrix <- utility_l_matrix + beta * (p_ll * v_l %*% t(ones) + p_lh * v_h %*% t(ones))
value_h_matrix <- utility_h_matrix + beta * (p_hl * v_l %*% t(ones) + p_hh * v_h %*% t(ones))
# find column max with max utility
tv_l <- apply(value_l_matrix, 2, max)
tv_h <- apply(value_h_matrix, 2, max)
tdecision_l <- apply(value_l_matrix, 2, which.max)
tdecision_h <- apply(value_h_matrix, 2, which.max)
# loop ends if no changes from previous iteration
test <- abs(max(tdecision_l - decision_l))+abs(max(tdecision_h - decision_h))
# update value grid and decision rule
decision_l <- tdecision_l
decision_h <- tdecision_h
v_l <- tv_l
v_h <- tv_h
}
# capital and consumption decision rule
policy_function_l <<- tibble(k = k, k_prime = min_k + decision_l*inc_k) %>%
mutate(c = z_l*k_prime^cd_k + (1-delta)*k - k_prime)
policy_function_h <<- tibble(k = k, k_prime = min_k + decision_h*inc_k) %>%
mutate(c = z_h*k_prime^cd_k + (1-delta)*k - k_prime)
v_l <<- v_l
v_h <<- v_h
}
solve_bellman_d()
solve_bellman_s()
save(ls(), file = "ps4_vonhafften_2a.RData")
save(list = ls(), file = "ps4_vonhafften_2a.RData")
load("ps4_vonhafften_2a.RData")
plot(1, type = "l", xaxs = "i", yaxs = "i", ylim=c(0,2), xlim=c(min_k, max_k), xlab = "k", ylab = "c", main = "Policy Function: c(k)")
lines(policy_function_d$k, policy_function_d$c)
lines(policy_function_h$k, policy_function_h$c, col = "red")
lines(policy_function_l$k, policy_function_l$c, col = "blue")
legend("topleft",
c("Deterministic", "Stochastic (High)", "Stochastic (Low)"),
col = c("black", "red", "blue"),
lty = 1)
plot(1, type = "l", xaxs = "i", yaxs = "i", ylim=c(0, 10), xlim=c(min_k, max_k), xlab = "k", ylab = "k'", main = "Policy Function: k'(k)")
lines(policy_function_d$k, policy_function_d$k_prime)
lines(policy_function_h$k, policy_function_h$k_prime, col = "red")
lines(policy_function_l$k, policy_function_l$k_prime, col = "blue")
legend("topleft",
c("Deterministic", "Stochastic (High)", "Stochastic (Low)"),
col = c("black", "red", "blue"),
lty = 1)
load("ps4_vonhafften_2a.RData")
n_periods <- 100000
burnin <- 1000
transition <- new("markovchain",
states = c("high", "low"),
transitionMatrix = matrix(c(p_hh, p_lh, p_hl, p_ll),
nrow = 2,
dimnames = list(c("high", "low"),
c("high", "low"))))
simulation <- tibble(shock = rmarkovchain(n = n_periods + burnin,
object = transition),
c = 1.2,
k = 3.6)
for (i in 1:(nrow(simulation)-1)) {
index <- policy_function_l$k == simulation$k[i]
if (simulation$shock[i] == "low") {
simulation$c[i] <- policy_function_l$c[index]
simulation$k[i+1] <- policy_function_l$k_prime[index]
}
if (simulation$shock[i] == "high") {
simulation$c[i] <- policy_function_h$c[index]
simulation$k[i+1] <- policy_function_h$k_prime[index]
}
}
simulation <- simulation %>%
slice_tail(n = n_periods) %>%
mutate(z = case_when(shock == "high" ~ 1.2,
shock == "low" ~ 0.8),
y = z * k ^ cd_k,
i = y - c,
r = z * cd_k * k ^ (cd_k - 1),
w = z * cd_l * k ^ cd_k)
results_s <-  simulation %>%
pivot_longer(cols = c("c", "k", "y", "i", "r", "w"),
names_to = "variable") %>%
group_by(variable) %>%
summarise(simulation = mean(value, na.rm = TRUE),
.groups = "drop")
solve_ss_d()
results_d <- tibble(variable = c("c", "i", "k", "r", "w", "y"),
deterministic = c(c_bar,
z_d * k_bar ^ cd_k - c_bar,
k_bar,
z_d * cd_k * k_bar ^ (cd_k - 1),
z_d * cd_l * k_bar ^ cd_k,
z_d * k_bar ^ cd_k))
save(list = ls(), file = "ps4_vonhafften_2b.RData")
load("ps4_vonhafften_2b.RData")
full_join(results_d, results_s, by="variable") %>%
kable(digits = 3)
load("ps4_vonhafften_2b.RData")
results_s_c <- simulation %>%
summarise(c_vol = sd(c),
i_vol = sd(i),
y_vol = sd(y),
c_y_corr = cor(c, y),
r_y_corr = cor(r, y)) %>%
pivot_longer(everything(),
names_to = "variable",
values_to = "simulation")
results_s_c %>%
kable(digits = 3)
c_matrix_high <- w_high * l_high + r_high * ones %*% t(k) + (1-delta) * ones %*% t(k)  -
k %*% t(ones)
load("ps4_vonhafften_1a.RData")
getwd("")
getwd()
setwd("/Users/alexandervonhafften/Documents/UW Madison/Fall 2020/problem_sets/econ_712b/")
load("ps4_vonhafften_1a.RData")
ls()
ls() != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
ls()[ls() != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")]
View(AAPL)
ls() c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
ls() != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
ls()[ls() != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")]
ls() %>% select(-c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low"))
x <- ls()
x[x != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")]
x != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
x
x != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
x != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
x != c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
x %in% c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low")
!(x %in% c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low"))
ls()[!(ls() %in% c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low"))]
ls()[!(ls() %in% c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low"))] %>%
save(list = ., file = "ps4_vonhafften_1a.RData")
load("ps4_vonhafften_1a.RData")
ls()[!(ls() %in% c("AAPL", "all", "high", "low", "middle", "seq9", "x", "y", "MLE", "MLEProb", "MOM", "MOMProb", "c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low"))] %>%
save(list = ., file = "ps4_vonhafften_1a.RData")
load("ps4_vonhafften_1a.RData")
