---
title: "ECON 712B - Problem Set 4"
author: "Alex von Hafften^[I worked on this problem set with a study group of Michael Nattinger, Andrew Smith, and Ryan Mather. I also discussed problems with Emily Case, Sarah Bass, and Danny Edgel.]"
date: "12/10/2020"
output: pdf_document
header-includes:
- \newcommand{\N}{\mathbb{N}}
- \newcommand{\Z}{\mathbb{Z}}
- \newcommand{\R}{\mathbb{R}}
- \newcommand{\Q}{\mathbb{Q}}
- \newcommand{\Lf}{\mathcal{L}}
- \newcommand{\graph}{\text{graph}}
- \usepackage{bm}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(markovchain)
library(knitr)
```

1. In Problem #3 on Problem Set 3 the wage and rate of return were given. Now suppose instead that they are determined from an aggregate production function, $Y = K^{\alpha}N^{1-\alpha}$, and an aggregate law of motion for the capital stock: $K' = (1-\delta)K + I$.  Assume that $\alpha = 0.36$ and $\delta = 0.08$.

```{r 1_simulation, echo = FALSE, eval=FALSE}
# parameters
beta <- 0.95
gamma <- 3
alpha <- 0.36
delta <- 0.08
l_low <- 0.7
l_high <- 1.1
Q <- matrix(c(0.85, 0.05, 0.15, 0.95), nrow = 2)

# capital grid
min_k <- 0.01
max_k <- 20
inc_k <- min_k
k <- seq(min_k, max_k, by = inc_k)
n <- length(k)
ones <- rep(1, times=n)

# initialize value grid 
v_low <- log(k)
v_high <- log(k)

# initialize decision rule grid
decision_low <- rep(0, times=n)
decision_high <- rep(0, times=n)

# initial guess
k_demand <- 6
diff <- 10000
k_tol <- 0.02
dist_tol <- .01

iter_master <- 1
max_iter <- 1000

# Master loop. 
# - Takes a capital demand level. 
# - Calculates interest rates and wages. 
# - Solve the household problem.  
# - Find marginal distribution of capital supply. 
# - Check if they are close. 
# - Then reruns with capital demand that is halfway 
  # between the previous guess and the implied capital supply.

while (abs(diff) > k_tol & iter_master < max_iter) {
  print(iter_master)
  print(paste("Capital Demand:", k_demand))

  # find interest rate from k_demand guess
  r_low <- alpha * k_demand ^ (alpha - 1) * l_low ^ (1 - alpha)
  r_high <- alpha * k_demand ^ (alpha - 1) * l_high ^ (1 - alpha)
  
  # wages from zero profit condition
  w_low <- (k_demand ^ (alpha) * l_low ^ (1-alpha) - r_low * k_demand)/l_low
  w_high <- (k_demand ^ (alpha) * l_high ^ (1-alpha) - r_high * k_demand)/l_high
  
  # create consumption matrices
  # (columns are different values of a; rows are values of a')
  c_matrix_low <- w_low * l_low + r_low * ones %*% t(k)  + (1-delta) * ones %*% t(k) - 
    k %*% t(ones)
  c_matrix_high <- w_high * l_high + r_high * ones %*% t(k) + (1-delta) * ones %*% t(k)  - 
    k %*% t(ones)
  
  # create flow utility matrices and set negative consumption levels to low value
  utility_matrix_low <- (c_matrix_low^(1-gamma))/(1-gamma)
  utility_matrix_low[c_matrix_low < 0|!is.finite(utility_matrix_low)] <- -1000
  
  utility_matrix_high <- (c_matrix_high^(1-gamma))/(1-gamma)
  utility_matrix_high[c_matrix_high < 0|!is.finite(utility_matrix_high)] <- -1000
  
  test <- 10
  iter_hh <- 1
  
  # solve household bellman equations:
  while (test != 0 & iter_hh < max_iter) {

    # create value matrix for different a and a' values with transition probabilities 
    # to next period shock
    value_matrix_low <- utility_matrix_low + beta * Q[1, 1] * v_low %*% t(ones) + 
      beta * Q[1, 2] * v_high %*% t(ones)
    value_matrix_high <- utility_matrix_high + beta * Q[2, 1] * v_low %*% t(ones) + 
      beta * Q[2, 2] * v_high %*% t(ones)
    
    # find max utility
    tv_low <- apply(value_matrix_low, 2, max)
    tv_high <- apply(value_matrix_high, 2, max)
    
    # find column with max utility
    tdecision_low <- apply(value_matrix_low, 2, which.max)
    tdecision_high <- apply(value_matrix_high, 2, which.max)
    
    # update test variable so loop ends if no changes from previous iteration
    test <- max(tdecision_low - decision_low) + max(tdecision_high - decision_high)
    
    # update value grid
    v_low <- tv_low
    v_high <- tv_high
    
    # update decision rule
    decision_low <- tdecision_low
    decision_high <- tdecision_high
    
    iter_hh <- iter_hh + 1
  }
  
  # Finds marginal distribution of capital supply
  diff <- 1000
  dist0 <- matrix(rep(1/(2*n), times = 2*n), ncol = 2)
  dist <- dist0
  iter <- 1
  
  while (diff > dist_tol & iter < max_iter ) {

    dist <- 0*dist0
    
    for (i in 1:n) {
      for (j in 1:2) {
        if (dist0[i, j] > .Machine$double.xmin) {
          if (j == 1){
            target <- decision_low[i]
          }
          if (j == 2){
            target <- decision_high[i]
          }
          
          dist[target, 1] <- dist[target, 1] + dist0[i, j] * Q[j, 1]
          dist[target, 2] <- dist[target, 2] + dist0[i, j] * Q[j, 2]
        }
      }
    }
    
    diff <- sum(abs(dist - dist0))
    
    if (abs(sum(dist) - 1) > .00001 | abs(sum(dist0) - 1) >  .00001 ) {
      print("PDFs aren't PDF!")
      
      plot(dist[,1], type ="l")
      lines(dist[,2], col = "red")
      
      print(sum(dist))
      print(sum(dist0))
      
      break
    }
    
    dist0 <- dist
    
    iter <- iter + 1
  }
  
  k_supply <- sum(apply(dist, 1, sum)*k)
  
  print(paste("Capital Supply:", k_supply))
  
  diff <- k_demand - k_supply
  iter_master <- iter_master + 1
  
  k_demand <- k[which.min(abs(0.9*k_demand + 0.1*k_supply - k))]
  
}

# save policy function based on decision rule
policy_function_low <- tibble(k = k, k_prime = min_k + decision_low*inc_k) %>%
  mutate(c = w_low * l_low + r_low * k + (1-delta) * k - k_prime)
  
policy_function_high <- tibble(k = k, k_prime = min_k + decision_high*inc_k) %>%
  mutate(c = w_high * l_high + r_high * k + (1-delta) * k - k_prime)

# Don't save the large matrices
ls()[!(ls() %in% c("c_matrix_high", 
                   "c_matrix_low", 
                   "utility_matrix_high", 
                   "utility_matrix_low", 
                   "value_matrix_high", 
                   "value_matrix_low"))] %>%
  save(list = ., file = "ps4_vonhafften_1a.RData")
```

(a) Find the equilibrium levels of the capital stock, the real wage, and the real interest rate.

The household Bellman equation becomes:

\begin{align*}
V(k, l) &= \max_{(c, k')} \Bigg\{\frac{c^{1-\gamma}}{1 - \gamma} + \beta \int V(k', l')Q(l, dl')\Bigg\} \\
\text{s.t. } & c + k' - (1-\delta)k = lw + rk  \\
\implies V(k, l) &= \max_{k'} \Bigg\{\frac{(w l + rk + (1-\delta)k - k')^{1-\gamma}}{1 - \gamma} + \beta \int V(k', l')Q(l, dl')\Bigg\}
\end{align*}

The firm maximizes profit in each period, so that in equilibrium the interest rate equal the marginal product of capital.  The profit function is CRS which implies the wage.

\begin{align*}
\max_{k, l} & K^{\alpha}N^{1-\alpha} - rK - wN \\
r &= \alpha K^{\alpha - 1} N^{1-\alpha} \\
w &= \frac{K^{\alpha}N^{1-\alpha} - rK}{N}
\end{align*}

Labor is exogenous and market clearing implies that $N = l_t$.  We need to numerically calculate capital.  The process starts with a guess for capital demand, which implies a wage and interest rate based on the firms' problem.  The next step in the process is to solve the household problem, which implies a policy function for consumption and capital holdings.  Then, the policy function implies a stationary distribution for capital, which implies a level of capital supply.  Finally, if the capital supply and the capital demand at the same then they imply that the market clears and are thus the equilibrium values.  Otherwise, the process is repeated with an updated guess for capital demanded.  By Walras' Law, the goods market clears at equilibrium.


```{r 1a_results, echo = FALSE}
load("ps4_vonhafften_1a.RData")

k_bar <- (k_demand + k_supply)/2

r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
  
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high

stationary_dist <- apply(dist, 2, sum)

tibble(capital = k_bar,
       wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
       interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>% 
  pivot_longer(cols = everything(),
               names_to ="variable",
               values_to = "equilibrium values") %>%
  kable(digits = 3)
```

(b) Plot the equilibrium distributions of income and consumption distribution. Compare the relative degree of inequality in the two distributions.

The marginal capital distribution implies a income and consumption distribution.  The consumption values range from 0 to 1.5.  The income ranges from about 0.2 (even at low levels of capital households are providing labor and earning labor income) to 3.

```{r 1b, echo = FALSE}
load("ps4_vonhafften_1a.RData")

r_low <- alpha * k ^ (alpha - 1) * l_low ^ (1 - alpha)
w_low <- (k ^ alpha * l_low ^ (1-alpha) - r_low * k)/l_low

r_high <- alpha * k ^ (alpha - 1) * l_high ^ (1 - alpha)
w_high <- (k ^ alpha * l_high ^ (1-alpha) - r_high * k)/l_high

labor_income_low <- w_low * l_low
labor_income_high <- w_high * l_high

interest_income_low <- r_low * k
interest_income_high <- r_high * k

income <- apply(cbind(.25*(interest_income_low+labor_income_low), 
                      .75*(interest_income_high+labor_income_high)), 1, sum)

pdf <- apply(dist, 1, sum)
cdf <- cumsum(pdf)

consumption <- delta * k

plot(x = consumption, y = cdf, type="l", xlab = "value", ylim = c(0, 1), xlim=c(0, 3))

lines(x= income, y= cdf, type="l", col = "red")

legend("bottomright",
       c("consumption", "income"),
       col = c("black", "red"),
       lty = 1)

```

(c) Now suppose that the borrowing constraint is loosened so that households face the debt limit $a_t \ge -2$ (rather than $a_t \ge 0$). What happens to the equilibrium results from part (a)?

Following the same procedure as in part (a), but with a capital grid that starts at -2, I find that the equilibrium level of capital is slightly lower with debt than without.  Households have some flexibility to borrow in case of low shocks, so they don't need as much savings. With the lower level of capital, interest rates are slightly higher.  Since capital and labor are complements in production, wages are slightly lower.

```{r 1c_simulation, echo = FALSE, eval=FALSE}
# This chunk runs the simulation.  No need to run it every time you knit.

# parameters
beta <- 0.95
gamma <- 3
alpha <- 0.36
delta <- 0.08
l_low <- 0.7
l_high <- 1.1
Q <- matrix(c(0.85, 0.05, 0.15, 0.95), nrow = 2)

# capital grid
min_k <- -2
max_k <- 20
inc_k <- 0.01
k <- seq(min_k, max_k, by = inc_k)
n <- length(k)
ones <- rep(1, times=n)

# initialize value grid 
v_low <- log(k-min_k+inc_k)
v_high <- log(k-min_k+inc_k)

# initialize decision rule grid
decision_low <- rep(0, times=n)
decision_high <- rep(0, times=n)

# initial guess
k_demand <- 6
diff <- 10000
k_tol <- 0.02
dist_tol <- .01

iter_master <- 1
max_iter <- 1000

# Master loop. Takes a capital demand level. Calculates interest rates and wages. Solve the household problem.  Find marginal distribution of capital supply. Check if they are close. Then reruns with capital demand that is halfway between the previous guess and the implied capital supply.

while (abs(diff) > k_tol & iter_master < max_iter) {
  print(iter_master)
  print(paste("Capital Demand:", k_demand))

  # find interest rate from k_demand guess
  r_low <- alpha * k_demand ^ (alpha - 1) * l_low ^ (1 - alpha)
  r_high <- alpha * k_demand ^ (alpha - 1) * l_high ^ (1 - alpha)
  
  # wages from zero profit condition
  w_low <- (k_demand ^ (alpha) * l_low ^ (1-alpha) - r_low * k_demand)/l_low
  w_high <- (k_demand ^ (alpha) * l_high ^ (1-alpha) - r_high * k_demand)/l_high
  
  # create consumption matrices
  # (columns are different values of a; rows are values of a')
  c_matrix_low <- w_low * l_low + r_low * ones %*% t(k)  + (1-delta) * ones %*% t(k) - k %*% t(ones)
  c_matrix_high <- w_high * l_high + r_high * ones %*% t(k) + (1-delta) * ones %*% t(k)  - k %*% t(ones)
  
  # create flow utility matrices and set negative consumption levels to low value
  utility_matrix_low <- (c_matrix_low^(1-gamma))/(1-gamma)
  utility_matrix_low[c_matrix_low < 0|!is.finite(utility_matrix_low)] <- -1000
  
  utility_matrix_high <- (c_matrix_high^(1-gamma))/(1-gamma)
  utility_matrix_high[c_matrix_high < 0|!is.finite(utility_matrix_high)] <- -1000
  
  test <- 10
  iter_hh <- 1
  
  # solve household bellman equations:
  while (test != 0 & iter_hh < max_iter) {

    # create value matrix for different a and a' values with transition probabilities 
    # to next period shock
    value_matrix_low <- utility_matrix_low + beta * Q[1, 1] * v_low %*% t(ones) + 
      beta * Q[1, 2] * v_high %*% t(ones)
    value_matrix_high <- utility_matrix_high + beta * Q[2, 1] * v_low %*% t(ones) + 
      beta * Q[2, 2] * v_high %*% t(ones)
    
    # find max utility
    tv_low <- apply(value_matrix_low, 2, max)
    tv_high <- apply(value_matrix_high, 2, max)
    
    # find column with max utility
    tdecision_low <- apply(value_matrix_low, 2, which.max)
    tdecision_high <- apply(value_matrix_high, 2, which.max)
    
    # update test variable so loop ends if no changes from previous iteration
    test <- max(tdecision_low - decision_low) + max(tdecision_high - decision_high)
    
    # update value grid
    v_low <- tv_low
    v_high <- tv_high
    
    # update decision rule
    decision_low <- tdecision_low
    decision_high <- tdecision_high
    
    iter_hh <- iter_hh + 1
  }
  
  # Finds marginal distribution of capital supply
  diff <- 1000
  dist0 <- matrix(rep(1/(2*n), times = 2*n), ncol = 2)
  dist <- dist0
  iter <- 1
  
  while (diff > dist_tol & iter < max_iter ) {

    dist <- 0*dist0
    
    for (i in 1:n) {
      for (j in 1:2) {
        if (dist0[i, j] > .Machine$double.xmin) {
          if (j == 1) target <- decision_low[i]
          if (j == 2) target <- decision_high[i]
          
          dist[target, 1] <- dist[target, 1] + dist0[i, j] * Q[j, 1]
          dist[target, 2] <- dist[target, 2] + dist0[i, j] * Q[j, 2]
        }
      }
    }
    
    diff <- sum(abs(dist - dist0))
    dist0 <- dist
    iter <- iter + 1
  }
  
  k_supply <- sum(apply(dist, 1, sum)*k)
  print(paste("Capital Supply:", k_supply))
  diff <- k_demand - k_supply
  iter_master <- iter_master + 1
  k_demand <- k[which.min(abs(0.9*k_demand + 0.1*k_supply - k))]
  
}

# save policy function based on decision rule
policy_function_low <- tibble(k = k, k_prime = min_k + decision_low*inc_k) %>%
  mutate(c = w_low * l_low + r_low * k + (1-delta) * k - k_prime)
  
policy_function_high <- tibble(k = k, k_prime = min_k + decision_high*inc_k) %>%
  mutate(c = w_high * l_high + r_high * k + (1-delta) * k - k_prime)

ls()[!(ls() %in% c("c_matrix_high", "c_matrix_low", "utility_matrix_high", "utility_matrix_low", "value_matrix_high", "value_matrix_low"))] %>%
  save(list = ., file = "ps4_vonhafften_1c.RData")
```

```{r 1c_results, echo = FALSE}
load("ps4_vonhafften_1a.RData")

k_bar <- (k_demand + k_supply)/2

r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
  
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high

stationary_dist <- apply(dist, 2, sum)

nodebt <- tibble(capital = k_bar,
       wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
       interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>% 
  pivot_longer(cols = everything(),
               names_to ="variable",
               values_to = "baseline")

load("ps4_vonhafften_1c.RData")

k_bar <- (k_demand + k_supply)/2

r_low <- alpha * k_bar ^ (alpha - 1) * l_low ^ (1 - alpha)
r_high <- alpha * k_bar ^ (alpha - 1) * l_high ^ (1 - alpha)
  
w_low <- (k_bar ^ (alpha) * l_low ^ (1-alpha) - r_low * k_bar)/l_low
w_high <- (k_bar ^ (alpha) * l_high ^ (1-alpha) - r_high * k_bar)/l_high

stationary_dist <- apply(dist, 2, sum)

tibble(capital = k_bar,
       wage = w_low*stationary_dist[1] + w_high*stationary_dist[2],
       interest_rate = r_low*stationary_dist[1] + r_high*stationary_dist[2]) %>% 
  pivot_longer(cols = everything(),
               names_to ="variable",
               values_to = "with debt") %>%
  full_join(nodebt, ., by ="variable") %>%
  kable(digits = 3)
```

\pagebreak

2. In Problem #3 on Problem Set 2 we calculated the solution of a deterministic optimal growth model. We now revisit that model, but add stochastic productivity shocks. Recall that we have the following specification: An infinitely-lived representative household owns a stock of capital which it rents to firms. The household’s capital stock $K$ depreciates at rate $\delta$. Households do not value leisure and are endowed with one unit of time each period with which they can supply labor $N$ to firms. They have standard time additive expected utility preferences with discount factor $\beta$ and period utility $u(c)$. Firms produce output according to the production function $zF(K, N)$ where $z$ is the level of technology. Set $\beta =0.95$, $\delta = 0.1$, $u(c) = c^{1 - \gamma}/(1 - \gamma)$ with $\gamma = 2$, and $F(K, N) = K^{0.35}N^{0.65}$. Before we set $z = 1$ but now we consider a Markov chain where for productivity where $z_t \in \{0.8, 1.2\}$ with transition matrix $P = [0.9, 0.1; 0.1, 0.9]$.

(a) Now solve for the optimal policy function $K_0 = g(K, z)$ and implied policy $c = c(K, z)$. Compare them to the solution in the deterministic case where $z_t \equiv 1$. How do they differ?

The policy function for both $k'$ and $c$ is higher than the deterministic case for the high productivity shock and lower for the low productivity shock.

```{r setup_model, echo = FALSE}
# parameters
beta <- 0.95
delta <- 0.1
z_d <- 1
gamma <- 2
cd_k <- 0.35 # cobb-douglas coefficient on capital
cd_l <- 0.65 # cobb-douglas coefficient on labor

# additional parameters for stochastic model
z_l <- .8
z_h <- 1.2
p_ll <- .9
p_hl <- .1
p_lh <- .1
p_hh <- .9

# capital grid
min_k <- 0.005
max_k <- 10
inc_k <- 0.005
k <- seq(min_k, max_k, by = inc_k)
n <- length(k)
```

```{r solve_ss, echo = FALSE}
solve_ss_d <- function() {
  # Steady state values
  k_bar <<- ((beta^(-1)-(1-delta))/(cd_k * z_d))^(1/(cd_k-1))
  c_bar <<- z_d * k_bar^cd_k - delta * k_bar
}
```


```{r solve_bellman_s, echo = FALSE, eval = FALSE}

# Solves bellman equation based on parameters above.
solve_bellman_s <- function() {
  ones <- rep(1, times=n)
  # initialize value grid and decision rule grid
  v_l <- rep(0, times=n)
  v_h <- rep(0, times=n)
  decision_l <- rep(0, times=n)
  decision_h <- rep(0, times=n)
  
  # create consumption and utility matrixes
  # (columns are different values of k; rows are values of k')
  c_l_matrix <- z_l*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
  c_h_matrix <- z_h*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
  
  utility_l_matrix <- (c_l_matrix^(1-gamma))/(1-gamma)
  utility_h_matrix <- (c_h_matrix^(1-gamma))/(1-gamma)
  utility_l_matrix[c_l_matrix < 0|!is.finite(utility_l_matrix)] <- -1000
  utility_h_matrix[c_h_matrix < 0|!is.finite(utility_h_matrix)] <- -1000
  
  test <- 10
  while (test != 0) {
    # create value matrix for all different k and k' values
    value_l_matrix <- utility_l_matrix + 
      beta * (p_ll * v_l %*% t(ones) + p_lh * v_h %*% t(ones))
    value_h_matrix <- utility_h_matrix + 
      beta * (p_hl * v_l %*% t(ones) + p_hh * v_h %*% t(ones))
    
    # find column max with max utility
    tv_l <- apply(value_l_matrix, 2, max)
    tv_h <- apply(value_h_matrix, 2, max)
    tdecision_l <- apply(value_l_matrix, 2, which.max)
    tdecision_h <- apply(value_h_matrix, 2, which.max)
    
    # loop ends if no changes from previous iteration
    test <- abs(max(tdecision_l - decision_l))+abs(max(tdecision_h - decision_h))
    
    # update value grid and decision rule
    decision_l <- tdecision_l
    decision_h <- tdecision_h
    v_l <- tv_l
    v_h <- tv_h
  }
  
  # capital and consumption decision rule
  policy_function_l <<- tibble(k = k, k_prime = min_k + decision_l*inc_k) %>%
    mutate(c = z_l*k_prime^cd_k + (1-delta)*k - k_prime)
  policy_function_h <<- tibble(k = k, k_prime = min_k + decision_h*inc_k) %>%
    mutate(c = z_h*k_prime^cd_k + (1-delta)*k - k_prime)
  
  v_l <<- v_l
  v_h <<- v_h
}
```


```{r solve_bellman_equation_d, echo = FALSE, eval = FALSE}
# Solves bellman equation based on parameters above.
solve_bellman_d <- function() {
  ones <- rep(1, times=n)
  
  # initialize value grid and decision rule grid
  v <- rep(0, times=n)
  decision <- rep(0, times=n)
  
  # create consumption and utility matrixes
  # (columns are different values of k; rows are values of k')
  c_matrix <- z_d*(ones %*% t(k))^cd_k + (1-delta)*(ones %*% t(k)) - k %*% t(ones)
  utility_matrix <- (c_matrix^(1-gamma))/(1-gamma)
  utility_matrix[c_matrix < 0|!is.finite(utility_matrix)] <- -1000
  
  test <- 10
  while (test != 0) {
    # create value matrix for all different k and k' values
    value_matrix <- utility_matrix + beta * v %*% t(ones)
    
    # find column max with max utility
    tv <- apply(value_matrix, 2, max)
    tdecision <- apply(value_matrix, 2, which.max)
    
    # loop ends if no changes from previous iteration
    test <- max(tdecision - decision)
    
    # update value grid and decision rule
    decision <- tdecision
    v <- tv
  }
  
  # capital and consumption decision rule
  policy_function_d <<- tibble(k = k, k_prime = min_k + decision*inc_k) %>%
    mutate(c = z_d*k_prime^cd_k + (1-delta)*k - k_prime)
  
  v_d <<- v
}

solve_bellman_d()
solve_bellman_s()

save(list = ls(), file = "ps4_vonhafften_2a.RData")
```

```{r 2a_plots, echo = FALSE, eval = FALSE}
load("ps4_vonhafften_2a.RData")

plot(1, type = "l", xaxs = "i", yaxs = "i", ylim=c(0,2), xlim=c(min_k, max_k), xlab = "k", ylab = "c", main = "Policy Function: c(k)")

lines(policy_function_d$k, policy_function_d$c)
lines(policy_function_h$k, policy_function_h$c, col = "red")
lines(policy_function_l$k, policy_function_l$c, col = "blue")

legend("topleft",
       c("Deterministic", "Stochastic (High)", "Stochastic (Low)"),
       col = c("black", "red", "blue"),
       lty = 1)

plot(1, type = "l", xaxs = "i", yaxs = "i", ylim=c(0, 10), xlim=c(min_k, max_k), xlab = "k", ylab = "k'", main = "Policy Function: k'(k)")

lines(policy_function_d$k, policy_function_d$k_prime)
lines(policy_function_h$k, policy_function_h$k_prime, col = "red")
lines(policy_function_l$k, policy_function_l$k_prime, col = "blue")

legend("topleft",
       c("Deterministic", "Stochastic (High)", "Stochastic (Low)"),
       col = c("black", "red", "blue"),
       lty = 1)

```


(b) Simulate the model to calculate time series of capital, output, consumption, investment, wages, and interest rates. What is the long run mean of consumption and capital? How do they compare to the deterministic steady state levels?

I ran a simulation with 100,000 periods that is preceded by 1,000 period burn-in period. In the simulation, households build up more saving in case of future negative productivity shocks.  In the table, we see that capital is noticably higher for the simulation.  Investment, consumption, output, and wages are all slightly higher in the simulation than in the deterministic model, which is consistent with households holding a higher amount of capital.  Interest rates are slightly lower due to the increased level of capital.

```{r 2b_stochastic, echo = FALSE, eval = FALSE}

load("ps4_vonhafften_2a.RData")

n_periods <- 100000
burnin <- 1000

transition <- new("markovchain", 
    states = c("high", "low"), 
    transitionMatrix = matrix(c(p_hh, p_lh, p_hl, p_ll), 
                              nrow = 2, 
                              dimnames = list(c("high", "low"), 
                                              c("high", "low"))))

simulation <- tibble(shock = rmarkovchain(n = n_periods + burnin, 
                                          object = transition),
                  c = 1.2,
                  k = 3.6)

for (i in 1:(nrow(simulation)-1)) {
  
  index <- policy_function_l$k == simulation$k[i]
  
  if (simulation$shock[i] == "low") {
    simulation$c[i] <- policy_function_l$c[index]
    simulation$k[i+1] <- policy_function_l$k_prime[index]
  }
  
  if (simulation$shock[i] == "high") {
    simulation$c[i] <- policy_function_h$c[index] 
    simulation$k[i+1] <- policy_function_h$k_prime[index]
  }
}

simulation <- simulation %>%
  slice_tail(n = n_periods) %>%
  mutate(z = case_when(shock == "high" ~ 1.2,
                       shock == "low" ~ 0.8),
         y = z * k ^ cd_k,
         i = y - c,
         r = z * cd_k * k ^ (cd_k - 1),
         w = z * cd_l * k ^ cd_k)

results_s <-  simulation %>%
  pivot_longer(cols = c("c", "k", "y", "i", "r", "w"),
               names_to = "variable") %>%
  group_by(variable) %>%
  summarise(simulation = mean(value, na.rm = TRUE), 
            .groups = "drop")

solve_ss_d()

results_d <- tibble(variable = c("c", "i", "k", "r", "w", "y"),
                    deterministic = c(c_bar,
                                      z_d * k_bar ^ cd_k - c_bar,
                                      k_bar,
                                      z_d * cd_k * k_bar ^ (cd_k - 1),
                                      z_d * cd_l * k_bar ^ cd_k,
                                      z_d * k_bar ^ cd_k))



save(list = ls(), file = "ps4_vonhafften_2b.RData")

```

```{r 2b_deterministic, echo = FALSE}

load("ps4_vonhafften_2b.RData")

full_join(results_d, results_s, by="variable") %>% 
  kable(digits = 3)

```

(c) How do the volatility of consumption and investment compare to that of output? What is the correlation between consumption and output? Between interest rates and output?

The volatility of consumption and investment is roughly half of the volatility of output.

The correlation between consumption and output is almost one.  This indicates that consumption and output comove quite closely.  The correlation between interest rates and output is approximately zero, which indicates that output and interest rates are unrelated.

```{r 2c, echo = FALSE}

load("ps4_vonhafften_2b.RData")


results_s_c <- simulation %>%
  summarise(c_vol = sd(c),
            i_vol = sd(i),
            y_vol = sd(y),
            c_y_corr = cor(c, y),
            r_y_corr = cor(r, y)) %>% 
  pivot_longer(everything(),
               names_to = "variable",
               values_to = "simulation")

results_s_c %>%
  kable(digits = 3)
```

\pagebreak

3. We now consider a recursive version of the neoclassical model with distorting taxes. An infinitely-lived representative household owns a stock of capital $k$ which it rents to firms. The household’s capital stock depreciates are rate $\delta$, and denote aggregate capital by $K$. Households do not value leisure and are endowed with one unit of time each period with which they can supply labor $N$ to firms. They have standard time additive expected utility preferences with discount factor $\beta$ and period utility $u(c)$. Firms produce output according to the production function $zF(K, N)$ where $z$ is the stochastic level of technology which is Markov with transition function $P(z', z)$. There is also a government which levies a proportional tax $\tau$ on households’ capital income and labor income. The tax rate is the same for both types of income and constant over time. The government uses the proceeds of the taxes to provide households with a lump sum transfer payment $T$ (which may vary over time), and suppose that in equilibrium the government must balance its budget every period.

(a) Define a recursive competitive equilibrium for this economy. Be specific about all of the objects in the equilibrium and the conditions they must satisfy.

The sequence formulation of the household problem is

\begin{align*}
\sum_{t=0}^\infty & \beta^t E_0[u(c_t)] \\
\text{s.t. } & c_t + k_{t+1} - (1 - \delta)k_t \le (1-\tau)(w_tN_t^s + r_tk_t) + T_t + \pi_t
\end{align*}

The household Bellman equation is:

\begin{align}
V(k, z) &= \max_{c, k'} \{ u(c) + \beta E[V(k', z')]\} \\
\text{s.t. } & c + k' - (1-\delta)k = (1- \tau)(wN^s + rk) + T + \pi
\end{align}

The firm problem is static.  In each period, the firm maximizes profit:

\begin{align}
\max_{K_t, N_t} z_tF(K_t, N_t^d) - r_tK_t - w_tN_t^d
\end{align}

The govenment budget constraint is

\begin{align}
T_t = \tau(w_tN_t + r_tk_t)
\end{align}

A recursive competitive equilibrium is an allocation $\{c_t, k_t, N_t, T_t, K_t, N_t, \pi_t\}_{t=0}^\infty$ and price system $\{w_t, r_t\}_{t=0}^\infty$ such that households optimize [Eq. (1) and (2)] and firms optimize [Eq. (3)], the government budget constraint holds [Eq. (4)], and markets clear: capital $K_t = k_t$, labor $N_t^s = N_t^d$, goods $z_tF(K_t, N_t^d) = c_t + k_{t+1}$.

(b)  Characterize the equilibrium by finding a functional (Euler) equation which the household’s optimal capital accumulation policy must satisfy (i.e. $k'$ as a function of $k, K, z$).

Since households do not value leisure, they will supply their unit of time as labor, so $N_t^s = 1 \implies N_t^d = 1$ by market clearing. Assume the production function is CRS implies that there is no profit in equilibrium $\pi_t = 0$. 

The household Bellman equation can be rewritten as:

$$
V(k, z) = \max_{k'}\{ u((1 -\tau)(w + rk) + T + (1-\delta)k-k') + \beta E[V(k', z')] \}
$$

FOC [$k'$]:

$$
u'(c) = \beta E[V'(k', z')]
$$

Envelope condition:

$$
V'(k, z) = u'(c)((1-\tau)r + (1-\delta))
$$

FOC and envelope condition imply a consumption Euler equation:

$$
u'(c) = \beta E[u'(c')((1-\tau)r' + (1-\delta))]
$$

The household's optimal capital accumulation policy must satisfy this equation, which is a function of $k$ through $c$ and $K$ through $r$.

(c) Impose the equilibrium conditions and find a functional equation which the aggregate capital accumulation policy must satisfy.

Solving the (static) firm problem, we find that the rental rate on capital is the marginal product of capital and the wage is the marginal product of labor.

$$
r = z F_K(K, 1)
$$

$$
w = z F_N(K, 1)
$$

Market clearing implies that $K = k$.  Thus, we can rewrite the consumption Euler equation:

\begin{align}
u'(c) = \beta E[u'(c')((1-\tau)z' F_K(k', 1) + (1-\delta))]
\end{align}

In addition, the law of motion of aggregate capital is:

\begin{align}
k' = zF(k, 1) + (1-\delta)k - c
\end{align}

(d) Show that when $\delta = 1$, the recursive competitive equilibrium allocation coincides with the solution of a social planner’s problem, but with a different discount factor. Interpret your result.

If $\delta = 1$, (5) and (6) simplify to:

$$
u'(c) = \beta E[u'(c')(1-\tau)z' F_K(k', 1)]
$$

$$
k' = zF(k, 1) - c
$$

The planner's sequence problem is 

\begin{align*}
\max_{\{c_t, k_t\}_{t=0}^\infty} & \sum_{t=0}^\infty \beta^t E_0 u (c_t) \\
\text{s.t. } & c_t + k_{t+1} = z_t F(k_t, 1) \\
\end{align*}

The Bellman equation is:

\begin{align*}
V(k) &= \max_{c, k'} \{ u(c) + \beta E [V(k')] \} \\
\text{s.t. } c + k' &= zF(k, 1) \\
\implies V(k) &= \max_{k'} \{ u(zF(k, 1) - k') + \beta E [V(k')] \}
\end{align*}

FOC [$k'$]:

$$
u'(c) = \beta E [V'(k')] 
$$

Envelope condition:

$$
V'(k) = u'(c)zF'(k, 1)
$$

The FOC and envelope condition imply a consumption Euler condition:

$$
u'(c) = \beta E [u'(c')z'F'(k', 1)] 
$$

The discount factor for the planner's problem does not depend on taxes whereas for the competitive equilibrium the proportional tax rate on income distorts the allocation. Taxes decrease the RHS of the Euler equations, so in equilibrium the LHS deceases.  Since $u$ is concavely increasing, the competitive equilibrium is associated with a higher level of consumption.  In essence, the tax on savings causes households to consume more and save less than the optimal allocation.

\pagebreak

4. Consider an endowment economy where a representative agent has recursive preferences of the Epstein-Zin type. That is, the utility $V_t$ of a consumption stream $\{c_s\}_{s=t}^\infty$ is evaluated recursively: $V_t = ((1-\beta)c_t^{1 - \rho} + \beta (E_t V_{t+1}^{1-\alpha})^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}}$, where $\rho > 0$ and $\alpha > 0$.  Notice that this is a combination of a CES aggregate (with parameter $\rho$) of current utility of consumption and a risk-adjustment (with parameter $\alpha$) of future utility.

(a)  Show that when $\alpha = \rho$ these preferences collapse to standard expected utility with a power utility function.

If $\gamma = \alpha = \rho$,

\begin{align*}
V_t &= ((1-\beta)c_t^{1 - \gamma} + \beta (E_t V_t^{1-\gamma})^{\frac{1-\gamma}{1 - \gamma}})^{\frac{1}{1-\gamma}} \\
\implies V_t^{1-\gamma} &= (1-\beta)c_t^{1 - \gamma} + \beta (E_t V_{t+1}^{1-\gamma}) \\
\implies W_t &= (1-\beta)c_t^{1 - \gamma} + \beta (E_t W_{t+1})\\
&= (1-\beta)c_t^{1 - \gamma} + \beta (E_t [(1-\beta)c_{t+1}^{1 - \gamma} + \beta (E_{t+1} W_{t+2})])\\
&= (1-\beta)c_t^{1 - \gamma} + \beta ((1-\beta)E_t [c_{t+1}^{1 - \gamma}] + \beta E_t [E_{t+1} W_{t+2}])\\
&= (1-\beta)\sum_{v=t}^{\infty} \beta^vE_t[c_v^{1 - \gamma}]\\
&= (1-\beta)(1-\gamma)\sum_{v=t}^{\infty} \beta^vE_t[\frac{c_v^{1 - \gamma}}{1-\gamma}]
\end{align*}

Where $W_t = V_t^{1-\gamma}$.  Since expected utility preferences are unique up to positive affine transformations, these preferences are equivalent to power utility.

(b)  Epstein-Zin preferences allow us to disentangle risk aversion and intertemporal substitution. How are these properties characterized here?

$\rho$ represents the amount of risk aversion across states of the world and $1/\alpha$ is the intertemporal elasticity of substitution.

(c) Find an expression for the intertemporal marginal rate of substitution (stochastic discount factor), which we can define here as: $S_t = \frac{\frac{\partial V_t}{\partial V_{t+1}}\frac{\partial V_{t+1}}{\partial c_{t+1}}}{\frac{\partial V_t}{\partial c_t}}$.

\begin{align*}
\frac{\partial V_t}{\partial V_{t+1}} 
&= \frac{1}{1-\rho}((1-\beta)c_t^{1 - \rho} + \beta (E_t [V_{t+1}^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho} - 1} \beta \frac{1-\rho}{1 - \alpha}(E_t V_{t+1}^{1-\alpha})^{\frac{1-\rho}{1 - \alpha}-1}(1-\alpha)E_t [V_{t+1}^{-\alpha}] \\ 
&= ((1-\beta)c_t^{1 - \rho} + \beta (E_t [V_{t+1}^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{\rho}{1-\rho}} \beta (E_t [V_{t+1}^{1-\alpha}])^{\frac{\alpha-\rho}{1 - \alpha}} E_t [V_{t+1}^{-\alpha}] \\
&= V_t^{\rho} \beta (E_t [V_{t+1}^{1-\alpha}])^{\frac{\alpha-\rho}{1 - \alpha}} E_t [V_{t+1}^{-\alpha}] 
\end{align*}

\begin{align*}
\frac{\partial V_t}{\partial c_t} 
&= \frac{1}{1-\rho}((1-\beta)c_t^{1 - \rho} + \beta (E_t [V_{t+1}^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}-1}(1-\beta)(1-\rho)c_t^{-\rho} \\
&= V_t^{\rho}(1-\beta)c_t^{-\rho}
\end{align*}

$$
\implies \frac{\partial V_{t+1}}{\partial c_{t+1}} 
= V_{t+1}^{\rho}(1-\beta)c_{t+1}^{-\rho}
$$

\begin{align*}
S_t 
&= \frac{\frac{\partial V_t}{\partial V_{t+1}}\frac{\partial V_{t+1}}{\partial c_{t+1}}}{\frac{\partial V_t}{\partial c_t}} \\
&= \frac{[V_t^{\rho} \beta (E_t [V_{t+1}^{1-\alpha}])^{\frac{\alpha-\rho}{1 - \alpha}} E_t [V_{t+1}^{-\alpha}]]
[ V_{t+1}^{\rho}(1-\beta)c_{t+1}^{-\rho}]}
{V_t^{\rho}(1-\beta)c_t^{-\rho}} \\
&= \frac{ \beta V_{t+1}^{\rho}c_{t+1}^{-\rho} (E_t [V_{t+1}^{1-\alpha}])^{\frac{\alpha-\rho}{1 - \alpha}} E_t [V_{t+1}^{-\alpha}]}
{c_t^{-\rho}} 
\end{align*}

\pagebreak

5. Now suppose that the endowment process (fruit from the Lucas tree) has i.i.d. growth rates, that is: $c_{t+1}/c_t = g + \sigma_c \varepsilon_{t+1}$ where $g > 0$ and $\sigma_c > 0$ are constants and $\varepsilon_t \sim N(0, 1)$.

(a) Conjecture a Markov pricing function, then write down the Bellman equation for the representative agent and find his optimality conditions.

Let $s_t$ be the fruit from Lucas trees.  We know that in equilibrium $c_t = s_t$.  Let $a_t$ be the holdings of trees from period $t-1$ to $t$.  Conjecture that the relative prices of tree to fruit is a function of the Markov state $p_t = p(s)$.  Thus, Bellman equation is

\begin{align*}
V(a(p(s) + s)) &= \max_{c, a'}((1-\beta)c^{1 - \rho} + \beta (E [ (V(a'(p(s') + s')))^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}}\\
\text{s.t. } & c + a'p(s) = a(p(s) + s)\\
\implies V(a(p(s) + s)) &= \max_{a'}((1-\beta)( a(p(s) + s) - a'p(s))^{1 - \rho} + \beta (E [(V(a'(p(s') + s')))^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}}\\
\end{align*}

FOC [$a'$]:

\begin{align*}
(1-\beta)(1-\rho)(a(p(s) + s)-a'p(s))^{-\rho}p(s) \\
= \beta \frac{1-\rho}{1 - \alpha} (E [(V(a'(p(s') + s')))^{1-\alpha}])^{\frac{\alpha - \rho}{1 - \alpha}}E[(1-\alpha)
E [(1-\alpha)(V(a'(p(s') + s')))^{-\alpha}V'(a'(p(s') + s'))]
\end{align*}

Envelope condition:

$$
V'(a(p(s) + s)) = (1-\beta)( a(p(s) + s) - a'p(s))^{- \rho}(p(c) + c) = (1-\beta)c^{- \rho}(p(c) + c)
$$

The FOC and envelope condition imply:

$$
\implies c^{-\rho}p(c) \\
= \beta (E [(V(a'(p(c') + s')))^{1-\alpha}])^{\frac{\alpha - \rho}{1 - \alpha}}E[
E [(1-\alpha)(V(a'(p(c') + s')))^{-\alpha}(1 - \rho)(c')^{- \rho}(p(c) + c)]
$$

$$
\implies 1 =\beta E\Bigg[S \frac{p(c')+c'}{p(c)}\Bigg]
$$

(b) Define a recursive competitive equilibrium, being specific about the objects which make it up.

The recursive competitive equilibrium is an allocation $\{a_t, c_t\}_{t=0}^\infty$ and a set of prices $\{p(c_t)\}_{t=0}^\infty$ such that households optimize per their Bellman equation and markets clear (i.e., trees $a_t = 1$ and goods $c_t = s_t$). 

\pagebreak

(c) Show that the value function can be written $V (c_t) = vc_t$ for some constant $v$, and find an expression for $\log S_t$.

Substitute $vc = V(a(p(s) + s))$ and $vc' = V(a(p(s') + s'))$ into the Bellman equation:

\begin{align*}
vc &= \max_{c, a'}((1-\beta)c^{1 - \rho} + \beta (E [ (vc')^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}}\\
\implies
vc &= \max_{c, a'}((1-\beta)c^{1 - \rho} + \beta (E [ v^{1-\alpha}c^{1-\alpha}(g + \sigma_c \varepsilon')^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}}\\
\implies
vc &= \max_{c, a'}((1-\beta)c^{1 - \rho} + \beta v^{1-\rho}c^{1-\rho}(E [ (g + \sigma_c \varepsilon')^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}}\\
\implies
v &= \max_{c, a'}((1-\beta) + \beta v^{1-\rho}(E [ (g + \sigma_c \varepsilon')^{1-\alpha}])^{\frac{1-\rho}{1 - \alpha}})^{\frac{1}{1-\rho}}
\end{align*}

Rewriting $S_t$:

\begin{align*}
\log (S_t) 
&= \log(\frac{ \beta V_{t+1}^{\rho}c_{t+1}^{-\rho} (E_t [V_{t+1}^{1-\alpha}])^{\frac{\alpha-\rho}{1 - \alpha}} E_t [V_{t+1}^{-\alpha}]}
{c_t^{-\rho}})\\
&= \log(\beta) + \rho \log( V_{t+1}) - \rho \log(c_{t+1}) + \frac{\alpha-\rho}{1 - \alpha}\log (E_t [V_{t+1}^{1-\alpha}]) + \log(E_t [V_{t+1}^{-\alpha}]) + \rho \log(c_t)
\end{align*}

Substituting in $V_{t+1} = v c_{t+1}$

\begin{align*}
\log (S_t) 
&= \log(\beta) + \rho \log( v c_{t+1}) - \rho \log(c_{t+1}) + \frac{\alpha-\rho}{1 - \alpha}\log (E_t [(v c_{t+1})^{1-\alpha}]) + \log(E_t [(v c_{t+1})^{-\alpha}]) + \rho \log(c_t)\\
&= \log(\beta) + \rho \log( v) + \rho\log( c_{t+1}) - \rho \log(c_{t+1}) + \frac{\alpha-\rho}{1 - \alpha}\log (E_t [(v c_{t+1})^{1-\alpha}]) + \log(E_t [(v c_{t+1})^{-\alpha}]) + \rho \log(c_t)\\
&= \log(\beta) + \rho \log( v) + \frac{\alpha-\rho}{1 - \alpha}\log (E_t [(v c_{t+1})^{1-\alpha}]) + \log(E_t [(v c_{t+1})^{-\alpha}]) + \rho \log(c_t)
\end{align*}

Thus, $v$ is a function of parameters and not consumption or savings, so it is constant.

(d) Find an expression for the risk-free rate. How does this differ from the standard CRRA case?

From lecture, we know that the price of a bond is $E[mx]$ where $m$ is the stochastic discount factor and $x$ is the payoff of the bond, which is 1 for a risk-free bond.  

For the Epstein-Zin preferences, we found that the stochastic discount factor is $S_t$.  Thus, the price of a risk-free bond is $E_t[S_t]$ and the risk-free return is $1/E_t[S_t]$.

For standard CRRA preferences, we found that the stochastic discount factor is $\beta\frac{u'(c_{t+1})}{u'(c_{t})}$.  Thus, the price of a risk-free bond is $E_t [\beta\frac{u'(c_{t+1})}{u'(c_{t})}]$ and the risk-free return is $1/E_t [\beta\frac{u'(c_{t+1})}{u'(c_{t})}]$.

(e) Find an expression for the return on the Lucas tree. How does this differ from the standard CRRA case?

Let $Q(s_t)$ be the price of a claim to the Lucas tree based on the realization of the shock $s_t$.  Thus, the payoff of a claim to the Lucas tree is the price of the tree in the next period plus its fruit: $Q(s_{t+1}) + s_{t+1}$.  Using the formula discussed in part (d), we know that $Q(s_t) = E_t[S_t(Q(s_{t+1}) + s_{t+1})]$.  Thus, the return on the Lucas tree is $1/E_t[S_t(Q(s_{t+1}) + s_{t+1})]$.

With CRRA preferences, the payoff of the claim to the Lucas tree is the same, but the stochastic discount factor is $\beta\frac{u'(c_{t+1})}{u'(c_{t})}$.

\pagebreak

## Appendix: Question 1

```{r, ref.label="1_simulation", eval = FALSE}
```

\pagebreak

## Appendix: Question 2

```{r, ref.label="setup_model", eval = FALSE}
```

```{r, ref.label="solve_bellman_s", eval = FALSE}
```