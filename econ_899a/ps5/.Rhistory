# Clear the memory
rm( list = ls() )
# install packages for dot product and graphing
library(pracma)
library(ggplot2)
### set working directory
# setwd('')
### run model with and without social security
for ( ss in 1:2 ){
##########################################################################
# Parameters
##########################################################################
# Demographics
J  <- 66                      # life-span
JR <- 46                      # age of retirement
tR <- J-JR+1                  # length of retirement
tW <- JR-1                    # length of working life
n  <- 0.011                   # Population growth
# Preferences
beta  <- 0.97                  # discount factor
sigma <- 2                    # coefficient of relative risk aversion
gamma <- 0.42                 # weight on consumption
# Production
alpha <- 0.36                 # production elasticity of capital
delta <- 0.06                 # rate of depreciation
# Social Security tax rate
if ( ss == 1 ){ tau <- 0.11 } # Use this for model with SS
if ( ss == 2 ){ tau <- 0    } # Use this for model without SS
# Measure of each generation
mass <- rep(1, times = J)
for ( ik0 in 2:J ){
mass[ik0]<-mass[ik0-1]/(1+n)
}
# Normalized measure of each generation (sums up to 1)
mass <- mass / sum(mass)
# Age-efficiency profile
e <- rep(0, times = tW)
e[1:11]  <- seq(from = 0.6,  to = 1,    length.out = 11)
e[11:21] <- seq(from = 1,    to = 1.08, length.out = 11)
e[21:31] <- seq(from = 1.08, to = 1.12, length.out = 11)
e[31:41] <- seq(from = 1.12, to = 1.06, length.out = 11)
e[41:45] <- seq(from = 1.06, to = 1.02, length.out = 5)
#  Capital grid
#  Be careful when setting maxkap across experiments! This value should not be binding!
#  To see if it's binding, check the optimal capital decision kp(k) of
#  every cohort.
#  If you have problems with convergence, increasing nk might help.
maxkap <- 14                               # maximum value of capital grid
minkap <- 0.01                             # minimum value of capital grid
nk     <- 180                              # number of grid points
inckap <- ((maxkap-minkap)/(nk-1)^2)       # distance between points
aux    <- 1:nk
kap    <- (minkap+inckap*(aux-1)^2)        # capital grid
# This formula makes a non-uniform grid with more density at lower range.
neg <- -1e10                              # very small number
#########################################################################
# Initial guesses for interest rate, wages and pension benefits
# Comment out the appropriate lines!
# Social Security
if ( ss == 1 ){
K0<-3.1392
L0<-0.3496
}
# No Social Security
if ( ss == 2){
K0<-3.9288
L0<- 0.3663
}
################################################################
## Loop over capital and labor
################################################################
tolk   <- 1e-3           # Numerical tolerance for capital
tollab <- 1e-3           # Numerical tolerance for labor
nq     <- 100            # Max number of iterations
q  <- 0                  # Counter for iterations
K1 <- K0 + 10
L1 <- L0 + 10
q <- q + 1
cat('\nIteration ',q,' out of ',nq,'\n')
# Prices
r0 <- alpha*((L0/K0)^(1-alpha))-delta  # <--- MBK = MCk
w0 <- (1-alpha)*((K0/L0)^alpha)        # <--- MBL = MCL
# Pension benefit
b <- (tau*w0*L0) / sum(mass[JR:J])     # <--- Government BC is satisfied
############################################################
# BACKWARD INDUCTION
############################################################
# Initialization
v      <- matrix(0, nrow = nk, ncol = J) # value function of agents
kapopt <- matrix(1, nrow = nk, ncol = J) # optimal savings of agents
# (store INDEX of k' in capital grid, not k' itself!)
labopt <-  matrix(1, nrow = nk, ncol = tW) # optimal labor supply
# Retired households
# Last period utility
cons <- ((1 + r0) * kap) + b                    # last period consumption (vector!)
util <- (cons^(1-sigma))/(1-sigma)       # last period utility (vector!)
v[,J] <- util                            # last period indirect utility (vector!)
}
seq(J-1,tW+1,by = -1)
a_l <- 0:10
b_l <- 0:10
z <- 2/(a_l^2 - 10 * a_l +27)
z
p <- 2/(b_l^2 - 10 * b_l +26)
p
a_l <- 0:10
b_l <- 0:10
p_a <- 2/(a_l^2 - 10 * a_l +27)
p_b <- 2/(b_l^2 - 10 * b_l +26)
p_a
p_b
u_a <- p_a * log(10 - a_l) + (1 - p_a) * log(10 + (5 - a_l *p_a)/(1 - p_a))
u_a
u_b <- p_b * log(10 - b_l) + (1 - p_b) * log(10 + (5 - b_l * p_b)/(1 - p_b))
u_a <- p_a * log(10 - a_l) + (1 - p_a) * log(10 + (5 - a_l * p_a)/(1 - p_a))
u_b <- p_b * log(10 - b_l) + (1 - p_b) * log(10 + (5 - b_l * p_b)/(1 - p_b))
log(10 + (5 - b_l * p_b)/(1 - p_b))
u_b
u_a > u_b
a_l <- 0:10
b_l <- 0:10
p_a <- 2/(a_l^2 - 10 * a_l +27)
p_b <- 2/(b_l^2 - 10 * b_l +26)
a_h <- (5 - a_l * p_a) / (1 - p_a)
b_h <- (5 - a_l * p_a) / (1 - p_a)
a_l <- 0:10
b_l <- 0:10
p_a <- 2/(a_l^2 - 10 * a_l +27)
p_b <- 2/(b_l^2 - 10 * b_l +26)
a_h <- (5 - a_l * p_a) / (1 - p_a)
b_h <- (5 - a_l * p_a) / (1 - p_a)
u_a <- p_a * log(10 + a_l) + (1 - p_a) * log(10 + b_1)
u_b <- p_b * log(10 + b_l) + (1 - p_b) * log(10 + b_h)
u_a <- p_a * log(10 + a_l) + (1 - p_a) * log(10 + b_h)
u_b <- p_b * log(10 + b_l) + (1 - p_b) * log(10 + b_h)
a_l <- 0:10
b_l <- 0:10
p_a <- 2/(a_l^2 - 10 * a_l +27)
p_b <- 2/(b_l^2 - 10 * b_l +26)
a_h <- (5 - a_l * p_a) / (1 - p_a)
b_h <- (5 - a_l * p_a) / (1 - p_a)
u_a <- p_a * log(10 + a_l) + (1 - p_a) * log(10 + b_1)
u_b <- p_b * log(10 + b_l) + (1 - p_b) * log(10 + b_h)
a_l <- 0:10
b_l <- 0:10
p_a <- 2/(a_l^2 - 10 * a_l +27)
p_b <- 2/(b_l^2 - 10 * b_l +26)
a_h <- (5 - a_l * p_a) / (1 - p_a)
b_h <- (5 - b_l * p_b) / (1 - p_b)
u_a <- p_a * log(10 + a_l) + (1 - p_a) * log(10 + b_h)
u_b <- p_b * log(10 + b_l) + (1 - p_b) * log(10 + b_h)
u_a > u_b
# calculates expected utility of a and b
u_a <- p_a * log(10 + a_l) + (1 - p_a) * log(10 + b_h)
u_b <- p_b * log(10 + b_l) + (1 - p_b) * log(10 + b_h)
u_a > u_b
plot(y=u_a, x= a_l, type = "l")
lines(y=u_b, x = b_l)
lines(y=u_b, x = b_l, col = "red")
plot(y=u_a, x= a_l, type = "l")
lines(y=u_b, x = b_l, col = "red")
u_a > u_b
a_l[1]
b_l[1]
a_h[i]
i = 1
i <- 1
a_l[i]
a_h[i]
p_a[i]
a_h[i](1 - p_a[i])
a_h[i]*(1 - p_a[i])
p_a[i]^2
sqrt(p_a[i])
p_b[i]
b_l[i]
b_h[i]
p_b[i]
u_a[i]
u_b[i]
e_a_3 = p_a * a_l^3 + (1-p_a) * a_h^3
e_a_3
e_a_3 = p_a * a_l^3 + (1-p_a) * a_h^3
e_b_3 = p_b * b_l^3 + (1-p_b) * b_h^3
e_a_3
e_a_3 > e_b_3
e_a_3 = p_a * a_l^3 + (1-p_a) * a_h^3
e_b_3 = p_b * b_l^3 + (1-p_b) * b_h^3
e_a_3 > e_b_3
e_a_3
e_b_3
u_a > u_b
plot(x = 9:16, y= log(9:16))
plot(x = 9:16, y= log(9:16), type = "l")
abline(v = 10 + a_l[i])
abline(v = 10 + a_l[i], col = "red")
abline(v = 10 + a_h[i], col = "red")
abline(h = u_a[i])
abline(h = u_a[i], col = "red")
# calculates expected utility of a and b
k = 10
u_a <- p_a * log(k + a_l) + (1 - p_a) * log(k + b_h)
u_b <- p_b * log(k + b_l) + (1 - p_b) * log(k + b_h)
plot(y=u_a, x= a_l, type = "l")
lines(y=u_b, x = b_l, col = "red")
u_a > u_b
e_a_3 = p_a * a_l^3 + (1-p_a) * a_h^3
e_b_3 = p_b * b_l^3 + (1-p_b) * b_h^3
e_a_3 > e_b_3
i <- 1
a_l[i]
a_h[i]
p_a[i]
u_a[i]
b_l[i]
b_h[i]
p_b[i]
u_b[i]
plot(x = 9:16, y= log(9:16), type = "l")
k = 10
abline(v = 10 + a_l[i], col = "red")
abline(v = 10 + a_h[i], col = "red")
abline(h = u_a[i], col = "red")
abline(v = k + b_l[i], col = "blue")
abline(v = k + b_h[i], col = "blue")
abline(h = u_b[i], col = "blue")
u_a > u_b
i <- 4
a_l[i]
a_h[i]
p_a[i]
u_a[i]
b_l[i]
b_h[i]
p_b[i]
b_l[i]
b_h[i]
p_b[i]
u_b[i]
plot_range <- c(min(k + a_l[i], k + b_l[i]), max(k + a_h[i], k + b_h[i]))
plot(x = plot_range, y= log(plot_range), type = "l")
abline(v = k + a_l[i], col = "red")
abline(v = k + a_h[i], col = "red")
abline(h = u_a[i], col = "red")
abline(v = k + b_l[i], col = "blue")
abline(v = k + b_h[i], col = "blue")
abline(h = u_b[i], col = "blue")
a_l[i]
a_h[i]
p_a[i]
u_a[i]
b_l[i]
b_h[i]
p_b[i]
u_b[i]
e_a_3 = p_a * a_l^3 + (1-p_a) * a_h^3
e_b_3 = p_b * b_l^3 + (1-p_b) * b_h^3
e_a_3 > e_b_3
i <- 4
a_l[i]
a_h[i]
p_a[i]
u_a[i]
b_l[i]
b_h[i]
p_b[i]
u_b[i]
plot_range <- c(min(k + a_l[i], k + b_l[i]), max(k + a_h[i], k + b_h[i]))
plot(x = plot_range, y= log(plot_range), type = "l")
abline(v = k + a_l[i], col = "red")
abline(v = k + a_h[i], col = "red")
abline(h = u_a[i], col = "red")
abline(v = k + b_l[i], col = "blue")
abline(v = k + b_h[i], col = "blue")
abline(h = u_b[i], col = "blue")
